#![no_std]

/*!
   This crate provides the proc macros used for defining CGP components.
*/

extern crate proc_macro;

use proc_macro::TokenStream;

/**
    `#[cgp_component]` is the most basic macro used to define a CGP component.

    The macro can be used on a Rust trait, which would be used as the base consumer
    trait for the macro to generate the other constructs, including the provider
    trait and the blanket implementations.

    The macro accepts two forms of attribute arguments. If only an identifier is
    provided, the identifier is used as the name of the provider trait. Otherwise,
    the macro accepts a list of key/value pairs, with the following keys allowed:

    - `name` - the name of the component. If not provided, the name would be in the
      format `{provider_trait_name}Component`.

    - `provider` - the name of the provider trait.

    - `context` - the identifier used for the generic context type. If not provided,
      the default identifier `Context` would be used.

    - `derive_delegate` - a list of generic dispatcher wrappers to derive the
      `UseDelegate` pattern on, with the matching generic parameters specified in
      the generic argument of the wrapper. Refer to `UseDelegate` for more details.

    ## Extension Macros

    There are two other macros that extends `#[cgp_component]` that can be used for
    deriving specialized CGP components: [`#[cgp_type]`](macro@cgp_type) can be used to
    define abstract type components, and [`#[cgp_getter]`](macro@cgp_getter) can be used
    to define getter components.

    These macros share the same arguments and expansion as `#[cgp_component]`,
    but also derive additional constructs for the specialized use cases.

    ## Example

    Given the following simplified component definition:

    ```rust,ignore
    #[cgp_component(Greeter)]
    pub trait CanGreet {
        fn greet(&self);
    }
    ```

    is equivalent to the fully explicit definition:

    ```rust,ignore
    #[cgp_component {
        name: GreeterComponent,
        provider: Greeter,
        context: Context,
    }]
    pub trait CanGreet {
        fn greet(&self);
    }
    ```
*/
#[proc_macro_attribute]
pub fn cgp_component(attr: TokenStream, item: TokenStream) -> TokenStream {
    cgp_macro_lib::cgp_component(attr.into(), item.into())
        .unwrap_or_else(syn::Error::into_compile_error)
        .into()
}

/**
    `#[cgp_provider]` is used when implementing a provider trait.

    It is applied on a provider trait `impl` block, and generates the accompanying
    `IsProviderFor` trait implementation that captures the same constraints as
    specified in the provider trait implementation.

    The macro is mainly used to propagate the provider implementation constraints
    through the `IsProviderFor` trait, so that Rust would print out any unsatisfied
    constraints in the error messages.

    In an ideal world, Rust should be able to print out the unsatisfied constraints,
    even if we don't have an `IsProviderFor` trait. However, since that is not the case,
    the use of this macro is required on all provider trait implementations to ensure
    that the unsatisfied constraints are always printed out.

    The macro accepts an optional identifier as its argument, which is used as the
    component name identifier. If not provided, the component name would default to
    the format `{provider_trait_name}Component`.

    Although the component name may be omitted when using `#[cgp_provider]`, a issue
    that arises is that the default component name identifier cannot be imported
    automatically by Rust Analyzer, due to it being an identifier generated by the
    macro. This means that the user cannot use the quick fix feature to auto import
    the component name, but instead has to add the import statement manually.

    ## Example

    Given the following provider trait implementation:

    ```rust,ignore
    #[cgp_provider]
    impl<Context> Greeter<Context> for GreetName
    where
        Context: HasName,
    {
        fn greet(context: &Context) {
            println!("Hello, {}!", context.name());
        }
    }
    ```

    Is equivalent to the following fully explicit implementation:

    ```rust,ignore
    #[cgp_provider(GreeterComponent)]
    impl<Context> Greeter<Context> for GreetName
    where
        Context: HasName,
    {
        fn greet(context: &Context) {
            println!("Hello, {}!", context.name());
        }
    }
    ```

    Which would generate the following `IsProviderFor` trait implementation:

    ```rust,ignore
    impl<Context> IsProviderFor<GreeterComponent, Context> for GreetName
    where
        Context: HasName,
    {}
*/
#[proc_macro_attribute]
pub fn cgp_provider(attr: TokenStream, item: TokenStream) -> TokenStream {
    cgp_macro_lib::cgp_provider(attr.into(), item.into())
        .unwrap_or_else(syn::Error::into_compile_error)
        .into()
}

/**
    The `#[cgp_new_provider]` macro is an extension to [`#[cgp_provider]`](macro@cgp_provider)
    that in addition to the derivation of `IsProviderFor`, also generates a new provider
    struct based on the `Self` type.

    This macro is a convenient shorthand for users to skip the manual definition of
    the provider struct. It is commonly used when user only wants to implement one
    provider trait for each provider struct.

    When the user wants to implement multiple provider traits for the same provider struct,
    the user should still explicitly define the provider struct, and use `#[cgp_provider]`
    instead.

    ## Example

    Given the following provider trait implementation:

    ```rust,ignore
    #[cgp_provider]
    impl<Context> Greeter<Context> for GreetName
    where
        Context: HasName,
    {
        fn greet(context: &Context) {
            println!("Hello, {}!", context.name());
        }
    }
    ```

    The provider struct `GreetName` is also generated as follows:

    ```rust
    struct GreetName;
    ```
*/
#[proc_macro_attribute]
pub fn cgp_new_provider(attr: TokenStream, item: TokenStream) -> TokenStream {
    cgp_macro_lib::cgp_new_provider(attr.into(), item.into())
        .unwrap_or_else(syn::Error::into_compile_error)
        .into()
}

/**
    `#[cgp_getter]` is an extension to [`#[cgp_component]`](macro@cgp_component) that
    derives additional getter constructs.

    This macro can only be used on traits that contains only getter-like methods.

    The macro accepts the same arguments as `#[cgp_component]`, and generates the same
    CGP component constructs. Additionally, it also generates implementation for the
    following getter providers:

    - `UseField<Tag>` - implements the provider trait using `HasField<Tag>`.
    - `UseFields` - implements the provider trait using `HasField`, with the tag
      being the same name as the getter methods.
    - `WithProvider<Provider>` - implements the provider trait if the given
      `Provider` implements `FieldGetter<ComponentName>`.

    ## Example

    Given the following getter component definition:

    ```rust,ignore
    #[cgp_component(NameGetter)]
    pub trait HasName {
        fn name(&self) -> &str;
    }
    ```

    The following getter providers are generated:

    ```rust,ignore
    #[cgp_provider]
    impl<Context, Tag> NameGetter<Context> for UseField<Tag>
    where
        Context: HasField<Tag, Value = String>,
    {
        fn get(context: &Context) -> &str {
            context.get_field(PhantomData).as_str()
        }
    }

    #[cgp_provider]
    impl<Context> NameGetter<Context> for UseFields
    where
        Context: HasField<symbol!("name"), Value = String>,
    {
        fn get(context: &Context) -> &str {
            context.get_field(PhantomData).as_str()
        }
    }

    #[cgp_provider]
    impl<Context, Provider> NameGetter<Context> for WithProvider<Provider>
    where
        Provider: FieldGetter<Context, NameGetterComponent, Value = String>,
    {
        fn get(context: &Context) -> &str {
            Provider::get_field(context, PhantomData).as_str()
        }
    }
    ```
*/
#[proc_macro_attribute]
pub fn cgp_getter(attr: TokenStream, item: TokenStream) -> TokenStream {
    cgp_macro_lib::cgp_getter(attr.into(), item.into())
        .unwrap_or_else(syn::Error::into_compile_error)
        .into()
}

/**
    `#[cgp_auto_getter]` is used on a regular getter Rust trait without turnning it
    into a CGP component. Instead, a blanket implementation is derived directly on
    that trait.

    This macro can only be used on traits that contains only getter-like methods.

    This macro is a simplified version of [`#[cgp_getter]`](macro@cgp_getter) that does
    not require explicit implementation or wiring. Instead, the trait would have a blanket
    implementation that is implemented only if the context implements `HasField` with the
    field having the exact same name as the getter methods.

    This macro serves as a convenient alternative, so that whenever there is a need to
    use the `HasField` trait directly, one can instead define a getter trait that is
    applied with `#[cgp_auto_getter]`.

    This can significantly improve developer experience, as the `HasField` trait can be
    confusing to new users, who may not be familiar with how the field tag being used
    as a type-level string instead of regular values.

    ## Example

    Given the following getter trait definition:

    ```rust,ignore
    #[cgp_auto_getter]
    pub trait HasName {
        fn name(&self) -> &str;
    }
    ```

    The trait will always be implemented for any struct that derives `HasField` with
    a `name` field of type `String`, without requiring further wiring. For example:

    ```rust,ignore
    #[derive(HasField)]
    struct Person {
        name: String,
    }
    ```

    or:

    ```rust,ignore
    #[derive(HasField)]
    struct Person {
        name: String,
        age: u8,
    }
    ```
*/
#[proc_macro_attribute]
pub fn cgp_auto_getter(attr: TokenStream, item: TokenStream) -> TokenStream {
    cgp_macro_lib::cgp_auto_getter(attr.into(), item.into())
        .unwrap_or_else(syn::Error::into_compile_error)
        .into()
}

/**
    The `delegate_components!` macro is used to define wiring of CGP components
    on a provider type.

    ## Type-Level Maps

    Conceptually, we can think of the use of `delegate_components!` as defining a
    type-level map, with the keys and values being types. When the keys are the
    CGP component name types and the values are the CGP providers, then
    `delegate_components!` is effectively implementing the specified providers
    on the target type by delegating them to the providers specified in the
    type-level map.

    The macro is implemented by having the target type implement the `DelegateComponent`
    trait, with the key used in the `Name` parameter and the value being set as the
    `Delegate` associated type.

    Additionally, for each key/value entry, the macro also generates implementation for
    the `IsProviderFor` trait, which would be used during provider trait implementation
    to propagate any unsatisfied constraints error to be shown to the user.

    ## Basic Syntax

    In its most basic form, the macro can be used by specifying a list of key/value pairs
    as follows:

    ```rust,ignore
    delegate_components! {
        MyComponents {
            KeyA: ValueA,
            KeyB: ValueB,
            ...
        }
    }
    ```

    This would turn the target type into a type-level map, which would contain the entries
    `KeyA` -> `ValueA`, `KeyB` -> `ValueB`, etc. For each `Key` and `Value`, the macro
    would generate the following implementation:

    ```rust,ignore
    impl DelegateComponent<Key> for MyComponents
    {
        type Delegate = Value;
    }

    impl<Context, Params> IsProviderFor<Key, Context, Params> for Value
    where
        Value: IsProviderFor<Key, Context, Params>,
    {
    }
    ```

    ## Grouping Keys

    The macro also supports grouping multiple keys together using the list syntax,
    when the grouped keys all map to the same value. This is useful when we want to
    delegate multiple CGP components to the same target provider.

    For example, given the following:

    ```rust,ignore
    delegate_components! {
        MyComponents {
            [
                KeyA,
                KeyB,
                ...
            ]:
                Value,
        }
    }
    ```

    It would be equivalent to the following:

    ```rust,ignore
    delegate_components! {
        MyComponents {
            KeyA: Value,
            KeyB: Value,
            ...
        }
    }
    ```

    ## Generating Mapping Struct

    By default, mapping types like `MyComponents` would be defined outside of `delegate_components!`
    as a dummy struct, or generated through other macros such as `#[cgp_context]`. However,
    `delegate_components!` also accepts an optional `new` keyword in front of the map type,
    in which it would also generate the struct definition for the mapping type.

    For example, given the following:

    ```rust,ignore
    delegate_components! {
        new MyComponents {
            KeyA: ValueA,
            KeyB: ValueB,
            ...
        }
    }
    ```

    The macro would also generate the `MyComponents` struct as follows:

    ```rust,ignore
    pub struct MyComponents;
    ```

    ## Inner Maps

    When defining component wiring that involves inner maps, such as with the use of
    `UseDelegate`, `delegate_components!` also supports defining the inner map type
    as well as the definition of inner key/value pairs all within the same macro invocation.

    For example, given the following:

    ```rust,ignore
    delegate_components! {
        MyComponents {
            OuterKey: UseDelegate<new InnerMap {
                InnerKeyA: InnerValueA,
                InnerKeyB: InnerValueB,
                ...
            }>,
        }
    }
    ```

    It would be the same as writing two separate calls to `delegate_components!` as follows:

    ```rust,ignore
    delegate_components! {
        MyComponents {
            OuterKey: UseDelegate<InnerMap>,
        }
    }

    delegate_components! {
        new InnerMap {
            InnerKeyA: InnerValueA,
            InnerKeyB: InnerValueB,
            ...
        }
    }
    ```
*/
#[proc_macro]
pub fn delegate_components(body: TokenStream) -> TokenStream {
    cgp_macro_lib::delegate_components(body.into())
        .unwrap_or_else(syn::Error::into_compile_error)
        .into()
}

/**
   The `check_components!` macro allows users to write compile-time tests to check
   for the correctness of component wiring for a CGP context.

   ## Example

   Given the following:

   ```rust,ignore
   check_components! {
       CanUsePerson for Person {
           GreeterComponent,
       }
   }
   ```


   The code above generates a *check trait* called `CanUsePerson`, which verifies
   whether the `Person` context implements the consumer trait for
   `GreeterComponent` (i.e., `CanGreet`):

   ```rust,ignore
   trait CanUsePerson<Component, Params>: CanUseComponent<Component, Params> {}

   impl CanUsePerson<GreeterComponent, ()> for Person {}
   ```
*/
#[proc_macro]
pub fn check_components(body: TokenStream) -> TokenStream {
    cgp_macro_lib::check_components(body.into())
        .unwrap_or_else(syn::Error::into_compile_error)
        .into()
}

/**
   The `delegate_and_check_components!` macro combines both `delegate_components!`
   and `check_components!`, allowing both delegation and checks within a single
   macro call.

   This is useful for the majority of simple cases, providing immediate feedback on
   whether the wiring works as intended.

   ## Example

   Given the following code:

   ```rust,ignore
   delegate_and_check_components! {
       CanUsePerson for Person;
       PersonComponents {
           GreeterComponent: GreetHello,
       }
   }
   ```

   is equivalent to writing the two separate macro calls:

   ```rust,ignore
   delegate_components! {
       PersonComponents {
           GreeterComponent: GreetHello,
       }
   }

   check_components! {
       CanUsePerson for Person {
           GreeterComponent,
       }
   }
   ```

   In more advanced cases, it may still be necessary to call `delegate_components!`
   and `check_components` separately. This applies to cases where the CGP traits
   contain additional generic parameters, or when presets are used.
*/
#[proc_macro]
pub fn delegate_and_check_components(body: TokenStream) -> TokenStream {
    cgp_macro_lib::delegate_and_check_components(body.into())
        .unwrap_or_else(syn::Error::into_compile_error)
        .into()
}

/**
    CGP presets are made of extensible collection of key/value mappings, that can be inherited
    to form new mappings.

    Instead of defining regular structs and build mappings with `delegate_components!`,
    presets are constructed as _modules_ using the `cgp_preset!` macro together with the
    `#[re_export_imports]`. For example, the same mappings earlier would be rewritten as:

    ```rust,ignore
    #[cgp::re_export_imports]
    mod preset {
        use crate_a::{KeyA, ...};
        use crate_b::{ValueA, ...};

        cgp_preset! {
            PresetA {
                KeyA: ValueA,
                KeyB: ValueB,
                KeyC: ValueC1,
            }
        }
    }
    ```

    The `#[cgp::re_export_imports]` macro is used over a surrogate `mod preset`, which wraps
    around the inner module to re-export the imports, so that they can be reused during the
    merging. This is required, because the merging works through macros, which don't have access to the actual type information. Aside from that, the macro re-exports all exports from the inner module, so that we can write regular code as if the `mod preset` modifier never existed.

    The macro `cgp_preset!` works similar to `delegate_components!`, but it defines a new
    _inner module_ that contains the mapping struct, together with macros and re-exports to
    support the merging operation.

    Similarly, the second preset would be re-written as:

    ```rust,ignore
    #[cgp::re_export_imports]
    mod preset {
        use crate_c::{KeyC, ...};
        use crate_d::{ValueD, ...};

        cgp_preset! {
            PresetB {
                KeyC: ValueC2,
                KeyD: ValueD,
                KeyE: ValueE,
            }
        }
    }
    ```

    To merge the two presets, we can define a new `PresetC` that _inherits_ from both `PresetA`
    and `PresetB`, like follows:

    ```rust,ignore
    #[cgp::re_export_imports]
    mod preset {
        use preset_a::PresetA;
        use preset_b::PresetB;
        use crate_f::{KeyF, ...};

        cgp_preset! {
            PresetC: PresetA + PresetB {
                override KeyC: ValueC2,
                KeyF: ValueF,
            }
        }
    }
    ```

    As we can see, CGP supports *multiple inheritance* for presets by using macros to "copy"
    over the entries from the parent preset. To resolve conflicts or override entries from
    the parent presets, the `override` keyword can be used to exclude a given mapping from
    being copied over and instead use the local definition. And since the underlying
    implementation still uses `DelegateComponent` to implement the lookup, any non-overridden
    conflicts would simply result in a trait error due to overlapping instances, thus preventing
    the diamond inheritance dillema.
*/
#[proc_macro]
pub fn cgp_preset(body: TokenStream) -> TokenStream {
    cgp_macro_lib::define_preset(body.into())
        .unwrap_or_else(syn::Error::into_compile_error)
        .into()
}

/**
    `#[cgp_type]` is an extension to [`#[cgp_component]`](macro@cgp_component) that
    derives additional constructs for abstract type components.

    This macro can only be used on an abstract type trait that contains a single
    associated type as its item, and nothing else.

    The macro can be used with no attribute argument, in which case the provider
    type would be named in the format `{associated_type_name}TypeProvider`.

    In addition to the component constructs generated by `#[cgp_component]`, the macro
    also generates a provider for `UseType<Type>`, that implements the provider trait
    using `Type`.

    The macro also generates a type alias for accessing the associated type, with the
    type alias named in the format `{associated_type_name}Of`.

    For advanced use cases, the macro also generates an implementation of
    `WithProvider<Provider>`, which implements the provider trait if the given
    `Provider` implements  `TypeProvider<Context, ComponentName>`.

    ## Example

    Given the following abstract type trait definition:

    ```rust,ignore
    #[cgp_type]
    pub trait HasNameType {
        type Name: Display;
    }
    ```

    would be equivalent to the following fully explicit definition:

    ```rust,ignore
    #[cgp_type {
        name: NameTypeProviderComponent,
        provider: NameTypeProvider,
        context: Context,
    }]
    pub trait HasNameType {
        type Name: Display;
    }
    ```

    Which would generate the following constructs:

    ```rust,ignore
    impl<Context, Type> NameTypeProvider<Context> for UseType<Type>
    where
        Type: Display,
    {
        type Name = Type;
    }

    type NameOf<Context> = <Context as HasNameType>::Name;

    impl<Context, Provider> HasNameType<Context> for WithProvider<Provider>
    where
        Provider: TypeProvider<Context, NameTypeProviderComponent>,
        Provider::Type: Display,
    {
        type Name = Provider::Type;
    }
    ```
*/
#[proc_macro_attribute]
pub fn cgp_type(attrs: TokenStream, body: TokenStream) -> TokenStream {
    cgp_macro_lib::cgp_type(attrs.into(), body.into())
        .unwrap_or_else(syn::Error::into_compile_error)
        .into()
}

/**
    The `#[cgp_context]` macro is used when defining a CGP context.

    The macro can be used with a struct definition. An optional identifier can be
    provided to be used as the name of the provider for the context. If not provided,
    the context provider would be named in the format `{struct_name}Components`.

    The macro generates a struct definition for the context provider, and implements
    `HasCgpProvider` for the context struct to point to the context provider.

    ## Example

    Given the following context definition:

    ```rust,ignore
    #[cgp_context]
    pub struct MyApp {
        name: String,
    }
    ```

    would be equivalent to the following fully explicit definition:

    ```rust,ignore
    #[cgp_context(MyAppComponents)]
    pub struct MyApp {
        name: String,
    }
    ```

    which would generate the following constructs:

    ```rust,ignore
    struct MyAppComponents;

    impl HasCgpProvider for MyApp {
        type CgpProvider = MyAppComponents;
    }
    ```

    ## Preset Inheritance

    The macro also allows the context provider to inherit its component mappings
    from a specified preset. The preset can be specified following a `:`, after
    the context provider name is specified.

    The context provider would implement `DelegateComponent` for all keys in the
    preset, with the `Delegate` target pointing to `Preset::Provider`. This is
    done through the `IsPreset` trait generated from the [`cgp_preset!`] macro.

    For example, given the following definition:

    ```rust,ignore
    #[cgp_context(MyAppComponents: MyPreset)]
    pub struct MyApp {
        name: String,
    }
    ```

    The following blanket implementation would be generated:

    ```rust,ignore
    impl<Name> DelegateComponent<Name> for MyAppComponents
    where
        Self: MyPreset::IsPreset<Name>,
    {
        type Delegate = MyPreset::Provider;
    }
    ```
*/
#[proc_macro_attribute]
pub fn cgp_context(attr: TokenStream, item: TokenStream) -> TokenStream {
    cgp_macro_lib::cgp_context(attr.into(), item.into())
        .unwrap_or_else(syn::Error::into_compile_error)
        .into()
}

/**
   The `#[blanket_trait]` macro can be used to define trait aliases that contain
   empty body and trivial blanket implementations.

   Developers can use the `#[blanket_trait]` macro to define trait aliases,
   as well as abstract type aliases for more advanced cases.

   ## Example

   Given the following:

   ```rust,ignore
   #[trait_alias]
   pub trait HasErrorType: Async + HasErrorType<Error: Async> {}
   ```

   automatically generates the following blanket implementation:

   ```rust,ignore
   impl<Context> HasErrorType for Context
   where
       Context: Async + HasErrorType<Error: Async> {}
   ```
*/
#[proc_macro_attribute]
pub fn blanket_trait(attr: TokenStream, item: TokenStream) -> TokenStream {
    cgp_macro_lib::blanket_trait(attr.into(), item.into())
        .unwrap_or_else(syn::Error::into_compile_error)
        .into()
}

#[proc_macro_attribute]
pub fn re_export_imports(attrs: TokenStream, body: TokenStream) -> TokenStream {
    cgp_macro_lib::re_export_imports(attrs.into(), body.into())
        .unwrap_or_else(syn::Error::into_compile_error)
        .into()
}

#[proc_macro]
pub fn replace_with(body: TokenStream) -> TokenStream {
    cgp_macro_lib::replace_with(body.into())
        .unwrap_or_else(syn::Error::into_compile_error)
        .into()
}

/**
    The `symbol!` macro is used to create a type-level string through the string literal
    given to the macro.

    The macro constructs the type-level string through a chain of `Char` types and
    terminated with the `Nil` type. In other words, it constructs a type-level list
    of characters to represent them as a type-level string.

    Read more about type-level strings in the documentation for `Char`.

    ## Example

    Given the following symbol definition:

    ```rust,ignore
    type Hello = symbol!("hello");
    ```

    The following type would be generated:

    ```rust,ignore
    type Hello = Char<'h', Char<'e', Char<'l', Char<'l', Char<'o', Nil>>>>>;
    ```

    which would be shown with the shortened representation as:

    ```rust,ignore
    type Hello = ι<'h', ι<'e', ι<'l', ι<'l', ι<'o', ε>>>>>;
    ```
*/
#[proc_macro]
pub fn symbol(body: TokenStream) -> TokenStream {
    cgp_macro_lib::make_symbol(body.into()).into()
}

/**
    The `Product!` macro is used to define a type-level list of types, a.k.a. a product type.

    Given a list of types to the macro, it would generate a chain of `Cons` types
    for each type in the list, and terminated with the `Nil` type.

    Read more about product types in the documentation for `Cons`.

    ## Example

    Given the following product type definition:

    ```rust,ignore
    type MyTypes = Product![u32, String, bool];
    ```

    The following type would be generated:

    ```rust,ignore
    type MyTypes = Cons<u32, Cons<String, Cons<bool, Nil>>>;
    ```

    which would be shown with the shortened representation as:

    ```rust,ignore
    type MyTypes = π<u32, π<String, π<bool, ε>>>;
    ```
*/
#[proc_macro]
#[allow(non_snake_case)]
pub fn Product(body: TokenStream) -> TokenStream {
    cgp_macro_lib::make_product_type(body.into()).into()
}

/**
   The `Sum!` macro is used to define a sum type, with the given list of types
   as disjoint variants.

   Given a list of types to the macro, it would generate a chain of `Either` types
   for each type in the list, and terminated with the `Void` type.

   Read more about sum types in the documentation for `Either`.

   ## Example

   Given the following sum type definition:

   ```rust,ignore
   type MyUnion = Sum![u32, String, bool];
   ```

   The following type would be generated:

   ```rust,ignore
   type MyUnion = Either<u32, Either<String, Either<bool, Void>>>;
   ```

   which would be shown with the shortened representation as:

   ```rust,ignore
   type MyUnion = σ<u32, σ<String, σ<bool, θ>>>;
   ```
*/
#[proc_macro]
#[allow(non_snake_case)]
pub fn Sum(body: TokenStream) -> TokenStream {
    cgp_macro_lib::make_sum_type(body.into()).into()
}

#[proc_macro]
pub fn product(body: TokenStream) -> TokenStream {
    cgp_macro_lib::make_product_expr(body.into()).into()
}

#[proc_macro_derive(HasField)]
pub fn derive_fields(item: TokenStream) -> TokenStream {
    cgp_macro_lib::derive_fields(item.into()).into()
}

#[proc_macro_derive(HasFields)]
pub fn derive_has_fields(item: TokenStream) -> TokenStream {
    cgp_macro_lib::derive_has_fields(item.into())
        .unwrap_or_else(syn::Error::into_compile_error)
        .into()
}

#[proc_macro_derive(BuildField)]
pub fn derive_builder(item: TokenStream) -> TokenStream {
    cgp_macro_lib::derive_build_field(item.into())
        .unwrap_or_else(syn::Error::into_compile_error)
        .into()
}

#[proc_macro_derive(ExtractField)]
pub fn derive_extractor(item: TokenStream) -> TokenStream {
    cgp_macro_lib::derive_extract_field(item.into())
        .unwrap_or_else(syn::Error::into_compile_error)
        .into()
}

#[proc_macro_derive(FromVariant)]
pub fn derive_from_variant(item: TokenStream) -> TokenStream {
    cgp_macro_lib::derive_from_variant(item.into())
        .unwrap_or_else(syn::Error::into_compile_error)
        .into()
}

#[proc_macro_derive(CgpVariant)]
pub fn derive_cgp_variant(item: TokenStream) -> TokenStream {
    cgp_macro_lib::cgp_variant(item.into())
        .unwrap_or_else(syn::Error::into_compile_error)
        .into()
}
